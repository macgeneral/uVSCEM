name: Publish

on:
  push:
    tags:
      - 'v[0-9]*.[0-9]*.[0-9]*'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run full publish pipeline without creating a GitHub release or publishing to PyPI'
        type: boolean
        default: true
      trigger_lint:
        description: 'Trigger a fresh Lint workflow run'
        type: boolean
        default: true
      trigger_test:
        description: 'Trigger a fresh Test workflow run (forced, even without code changes)'
        type: boolean
        default: true
      trigger_build:
        description: 'Trigger a fresh Build workflow run (forced, even without code changes)'
        type: boolean
        default: true

concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: false

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      actions: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.sha }}
          fetch-depth: 0

      - name: Set wait floor for manual dispatch
        id: wait_floor
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          echo "min_created_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"

      - name: Trigger upstream workflows for manual runs
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event.inputs.trigger_lint }}" == "true" ]]; then
            gh workflow run lint.yml --ref "${{ github.ref_name }}"
          fi
          if [[ "${{ github.event.inputs.trigger_test }}" == "true" ]]; then
            gh workflow run test.yml --ref "${{ github.ref_name }}" -f force=true
          fi
          if [[ "${{ github.event.inputs.trigger_build }}" == "true" ]]; then
            gh workflow run build.yml --ref "${{ github.ref_name }}" -f force=true
          fi

      - name: Wait for lint to pass
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.trigger_lint == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          WAIT_MIN_CREATED_AT: ${{ steps.wait_floor.outputs.min_created_at }}
        run: bash scripts/wait-for-workflow.sh "Lint" "${{ github.sha }}" "${{ github.repository }}" 50 30 "${WAIT_MIN_CREATED_AT}"

      - name: Wait for tests to pass
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.trigger_test == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          WAIT_MIN_CREATED_AT: ${{ github.event_name == 'workflow_dispatch' && steps.wait_floor.outputs.min_created_at || '' }}
        run: bash scripts/wait-for-workflow.sh "Test" "${{ github.sha }}" "${{ github.repository }}" 50 30 "${WAIT_MIN_CREATED_AT}"

      - name: Wait for build binaries
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.trigger_build == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          WAIT_MIN_CREATED_AT: ${{ github.event_name == 'workflow_dispatch' && steps.wait_floor.outputs.min_created_at || '' }}
        run: bash scripts/wait-for-workflow.sh "Build" "${{ github.sha }}" "${{ github.repository }}" 50 30 "${WAIT_MIN_CREATED_AT}"

  prepare:
    runs-on: ubuntu-latest
    needs: orchestrate
    timeout-minutes: 60
    permissions:
      actions: read
      contents: read
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.sha }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6.2.0
        with:
          python-version: "3.10"

      - name: Install uv
        uses: astral-sh/setup-uv@eac588ad8def6316056a12d4907a9d4d84ff7a3b # v7.3.0
        with:
          version: "0.10.6"
          checksum: "aaa402e19d14a6b9a4267fcf4ec35380f804c68923525cea67cd6ee05bb4e930"
          enable-cache: true
          cache-dependency-glob: |
            pyproject.toml
            uv.lock

      - name: Install dependencies
        run: uv sync --frozen --group publish

      - name: Strip CI badges from README for PyPI
        run: sed -i '3,/^[[:space:]]*$/d' README.md

      - name: Build distributions
        run: uv build

      - name: Find build run ID
        id: find-build
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            echo "Dry-run mode: allowing fallback to latest compatible historical Build run."
            bash scripts/check-build-needed.sh --find-run-id \
              "${{ github.sha }}" \
              "${{ github.repository }}" \
              "Build" \
              "*"
          else
            echo "Publish mode: requiring successful Build run for exact SHA."
            bash scripts/check-build-needed.sh --find-run-id-exact \
              "${{ github.sha }}" \
              "${{ github.repository }}" \
              "Build"
          fi

      - name: Log selected build run ID
        run: |
          echo "Selected Build run ID: ${{ steps.find-build.outputs.run-id }}"

      - name: Extract build binaries
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          run-id: ${{ steps.find-build.outputs.run-id }}
          github-token: ${{ github.token }}
          path: dist-binaries
          merge-multiple: true

      - name: Normalize binary artifacts
        run: |
          mkdir -p dist-binaries-flat
          find dist-binaries -type f -name 'default.gitignore' -delete
          find dist-binaries -type f -name 'uvscem-*' -exec cp -f {} dist-binaries-flat/ \;
          BIN_COUNT="$(find dist-binaries-flat -maxdepth 1 -type f -name 'uvscem-*' | wc -l)"
          echo "Found ${BIN_COUNT} binary file(s) in dist-binaries-flat"
          if [[ "${BIN_COUNT}" -eq 0 ]]; then
            echo "::error::No uvscem-* binaries found after artifact normalization; aborting early."
            exit 1
          fi

      - name: Generate SHA-256 checksums
        run: |
          cd dist-binaries-flat
          sha256sum uvscem-* > checksums.sha256
          cat checksums.sha256

      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Sign binaries with Sigstore
        run: |
          for bin in dist-binaries-flat/uvscem-*; do
            cosign sign-blob --yes --bundle "${bin}.bundle" "${bin}"
          done

      - name: Stage release assets
        run: |
          mkdir -p release-assets
          cp dist/*.whl release-assets/
          cp dist/*.tar.gz release-assets/
          cp dist-binaries-flat/uvscem-* release-assets/
          cp dist-binaries-flat/checksums.sha256 release-assets/

      - name: Verify staged release assets
        run: |
          set -euo pipefail
          test -f release-assets/checksums.sha256
          test -n "$(find release-assets -maxdepth 1 -type f -name '*.whl' -print -quit)"
          test -n "$(find release-assets -maxdepth 1 -type f -name '*.tar.gz' -print -quit)"
          test -n "$(find release-assets -maxdepth 1 -type f -name 'uvscem-*' -print -quit)"
          if find release-assets -maxdepth 1 -type f -name 'default.gitignore' | grep -q .; then
            echo "default.gitignore found in staged release assets" >&2
            exit 1
          fi
          ls -1 release-assets

      - name: Generate release notes
        id: release_notes
        run: |
          TARGET_REF="${{ github.sha }}"
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            CURRENT_TAG="${{ github.ref_name }}"
            PREV_TAG="$(git tag --sort=-version:refname | grep -vx "${CURRENT_TAG}" | head -1 || true)"
            if [[ -n "${PREV_TAG}" ]]; then
              RANGE="${PREV_TAG}..${CURRENT_TAG}"
            else
              RANGE="${CURRENT_TAG}"
            fi
          else
            LAST_TAG="$(git describe --tags --abbrev=0 "${TARGET_REF}" 2>/dev/null || true)"
            if [[ -n "${LAST_TAG}" ]]; then
              RANGE="${LAST_TAG}..${TARGET_REF}"
            else
              RANGE="${TARGET_REF}"
            fi
          fi
          NOTES="$(git log "${RANGE}" --pretty=format:'- %s (%h)' --no-merges)"
          {
            echo 'notes<<EOF'
            echo "${NOTES}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Write dry-run release notes summary
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run == 'true' }}
        run: |
          {
            echo "## Dry-run release notes preview"
            echo
            echo "- Ref: \`${{ github.ref_name }}\`"
            echo "- Commit: \`${{ github.sha }}\`"
            echo
            echo "### Notes"
            echo
            echo "${{ steps.release_notes.outputs.notes }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Persist release notes file
        run: |
          printf '%s\n' "${{ steps.release_notes.outputs.notes }}" > release-notes.md

      - name: Upload staged release assets
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: release-assets
          path: |
            release-assets
            release-notes.md
          if-no-files-found: error

  publish-release:
    runs-on: ubuntu-latest
    needs: prepare
    if: ${{ github.event_name == 'push' || github.event.inputs.dry_run != 'true' }}
    timeout-minutes: 30
    environment: pypi
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Validate semantic version tag
        run: |
          SEMVER_REGEX='^v[0-9]+\.[0-9]+\.[0-9]+$'
          if ! [[ "${{ github.ref_name }}" =~ ${SEMVER_REGEX} ]]; then
            echo "Tag ${{ github.ref_name }} is not a valid version tag (expected v<major>.<minor>.<patch> with only numeric parts)"
            exit 1
          fi

      - name: Verify tag signature
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          python - <<'PY'
          import json
          import os
          import urllib.request

          token = os.environ["GH_TOKEN"]
          repo = "${{ github.repository }}"
          tag = "${{ github.ref_name }}"

          def api_get(url):
              req = urllib.request.Request(
                  url,
                  headers={
                      "Accept": "application/vnd.github+json",
                      "Authorization": f"Bearer {token}",
                      "User-Agent": "uvscem-publish",
                      "X-GitHub-Api-Version": "2022-11-28",
                  },
              )
              with urllib.request.urlopen(req) as resp:
                  return json.load(resp)

          ref_data = api_get(f"https://api.github.com/repos/{repo}/git/refs/tags/{tag}")
          obj = ref_data["object"]

          if obj["type"] != "tag":
              raise SystemExit(
                  f"Tag {tag!r} is not an annotated tag (type={obj['type']!r}). "
                  "Only signed annotated tags are accepted for publishing."
              )

          tag_data = api_get(f"https://api.github.com/repos/{repo}/git/tags/{obj['sha']}")
          verification = tag_data.get("verification", {})
          verified = verification.get("verified", False)
          reason = verification.get("reason", "unknown")

          if not verified:
              raise SystemExit(
                  f"Tag {tag!r} signature verification failed (reason={reason!r}). "
                  "Ensure the tag is signed with a GPG key registered on GitHub."
              )

          print(f"Tag {tag!r} signature verified by GitHub (reason={reason!r}).")
          PY

      - name: Download staged release assets
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: release-assets
          path: .

      - name: Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
        with:
          tag_name: ${{ github.ref_name }}
          body_path: release-notes.md
          generate_release_notes: true
          files: release-assets/*
          make_latest: true

      - name: Stage Python distributions for PyPI
        run: |
          mkdir -p dist
          cp release-assets/*.whl release-assets/*.tar.gz dist/

      - name: Publish to PyPI
        id: pypi-publish
        uses: pypa/gh-action-pypi-publish@ed0c53931b1dc9bd32cbe73a98c7f6766f8a527e # v1.13.0
        with:
          attestations: true

      - name: Rollback GitHub Release and tag on PyPI failure
        if: failure() && steps.create-release.outcome == 'success'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "PyPI publish failed â€” rolling back GitHub Release and deleting tag ${{ github.ref_name }}."
          gh release delete "${{ github.ref_name }}" \
            --repo "${{ github.repository }}" \
            --yes \
            --cleanup-tag \
            || echo "::warning::Release rollback failed; manual cleanup of release and tag ${{ github.ref_name }} may be required."
